use clap::{arg, command, value_parser, Command};
use ontodev_valve::configure_and_or_load;
use std::error;
use std::fs;
use std::fs::File;
use std::fs::OpenOptions;
use std::io::{prelude::*, BufReader};
use std::path::Path;
use toml::map::Map;
use toml::Value;

fn add_to_gitignore(input: &str) -> Result<String, String> {
    if Path::new(".gitignore").exists() {
        let file = File::open(".gitignore").unwrap();
        let reader = BufReader::new(file);

        let mut found = false; //if true, then input is already in .gitignore
        let mut last_line_empty = false;
        let mut modified = false; //if true, then nanobot has already modified .gitignore

        for line in reader.lines() {
            let string = line.unwrap();
            if string.contains(input) {
                found = true;
            }
            if string.trim().eq("") {
                last_line_empty = true;
            } else {
                last_line_empty = false;
            }
            if string.contains("Generated by nanobot") {
                modified = true;
            }
        }

        if !found {
            if modified {
                //insert input in .gitignore
                //where nanobot has already modified the file previously
                let mut file = OpenOptions::new().write(true).open(".gitignore").unwrap();

                let file_string = fs::read_to_string(".gitignore").unwrap();
                let mut file_lines: Vec<&str> = file_string.split("\n").collect();
                for (pos, line) in file_lines.clone().iter().enumerate() {
                    if line.contains("Generated by nanobot") {
                        file_lines.insert(pos + 1, input);
                    }
                }
                let file_res = file_lines.join("\n");

                if let Err(e) = write!(file, "{}", file_res) {
                    eprintln!("Couldn't write to file: {}", e);
                }
                Ok(String::from("NotFound-Modified"))
            } else {
                let mut file = OpenOptions::new()
                    .write(true)
                    .append(true)
                    .open(".gitignore")
                    .unwrap();

                if !last_line_empty {
                    if let Err(e) = writeln!(file, "") {
                        eprintln!("Couldn't write to file: {}", e);
                    }
                }

                if let Err(e) = writeln!(file, "# Generated by nanobot") {
                    eprintln!("Couldn't write to file: {}", e);
                }

                if let Err(e) = writeln!(file, "{}", input) {
                    eprintln!("Couldn't write to file: {}", e);
                }
                Ok(String::from("NotFound-NotModified"))
            }
        } else {
            //input is already in .gitignore
            Ok(String::from("Found"))
        }
    } else {
        Ok(String::from("No .gitignore"))
    }
}

async fn init(database: &str) -> Result<String, String> {
    match fs::create_dir_all("src/schema") {
        Err(_x) => return Err(String::from("Couldn't create folder src/schema")),
        Ok(_x) => {}
    };

    match create_table_tsv() {
        Err(_x) => return Err(String::from("Couldn't write table.tsv")),
        Ok(_x) => {}
    };

    match create_column_tsv() {
        Err(_x) => return Err(String::from("Couldn't write column.tsv")),
        Ok(_x) => {}
    };

    match create_datatype_tsv() {
        Err(_x) => return Err(String::from("Couldn't write datatype.tsv")),
        Ok(_x) => {}
    };

    //create database
    match File::create(database) {
        Err(_x) => return Err(String::from("Couldn't create database")),
        Ok(_x) => {}
    }

    //add database to .gitignore
    match add_to_gitignore(database) {
        Err(x) => return Err(x),
        Ok(_x) => {}
    }

    //load tables into database
    let _config = configure_and_or_load("src/schema/table.tsv", database, true).await;

    if Path::new("nanobot.toml").exists() {
        Err(String::from("nanobot.toml file already exists."))
    } else {
        let toml = r#"[tool]
name = "nanobot"
version = "0.1.0"
edition = "2021"
"#;

        fs::write("nanobot.toml", toml).expect("Unable to write file");

        Ok(String::from("Hello world"))
    }
}

fn create_table_tsv() -> Result<(), Box<dyn error::Error>> {
    let data = r#"table	path	description	type
table	src/schema/table.tsv	All of the tables in this project.	table
column	src/schema/column.tsv	Columns for all of the tables.	column
datatype	src/schema/datatype.tsv	Datatypes for all of the columns	datatype
"#;
    fs::write("src/schema/table.tsv", data).expect("Unable to write file");

    Ok(())
}

fn create_column_tsv() -> Result<(), Box<dyn error::Error>> {
    let data = r#"table	column	nulltype	datatype	structure	description
table	table		label	unique	name of this table
table	path		line		path to the TSV file for this table, relative to the table.tsv file
table	type	empty	table_type		type of this table, used for tables with special meanings
table	description	empty	text		a description of this table
column	table		label	from(table.table)	the table that this column belongs to
column	column		label		the name of this column
column	nulltype	empty	word	from(datatype.datatype)	the datatype for NULL values in this column
column	datatype		word	from(datatype.datatype)	the datatype for this column
column	structure	empty	label		schema information for this column
column	description	empty	text		a description of this column
datatype	datatype		word	primary	the name of this datatype
datatype	parent	empty	word	tree(datatype)	the parent datatype
datatype	condition	empty	line		the method for testing the datatype
datatype	description	empty	text		a description of this datatype
datatype	SQL type	empty	sql_type		the SQL type for representing this data
datatype	HTML type	empty	html_type		the HTML type for viewing and editing this data
"#;
    fs::write("src/schema/column.tsv", data).expect("Unable to write file");

    Ok(())
}

fn create_datatype_tsv() -> Result<(), Box<dyn error::Error>> {
    let data = r#"datatype	parent	condition	description	SQL type	HTML type
text			any text	TEXT	textarea
empty	text	equals('')	the empty string	NULL	
line	text	exclude(/\\\\\\\n/)	one line of text		text
label	line	match(/[^\s]+.+[^\s]/)	text that does not begin or end with whitespace		
word	label	exclude(/\W/)	a single word: letters, numbers, underscore		
table_type	word	in('table', 'column', 'datatype')	a VALVE table type		search
sql_type	word	in('NULL', 'TEXT', 'INT')	a SQL type		search
html_type	word	in('text', 'textarea', 'search', 'radio', 'number', 'select')	an HTML form type		search
"#;
    fs::write("src/schema/datatype.tsv", data).expect("Unable to write file");

    Ok(())
}


/// Merge two toml::Values.
/// The second argument is given priority in case of conflicts.
/// So, given two toml::Values d and c,
/// where d is considered a default configuartion,
/// and a is a custom configuration deviating from d.
/// Then, merge(d,c) keeps the custom values specified in c
/// and includes default values from d not specified in c.
///
/// #Examples
///
/// ```
/// use toml::Value;
///
/// let s1 = r#"
/// [package]
/// name = "macrobot"
/// version = "0.1.0"
/// edition = "2021"
/// "#;
///
/// let s2 = r#"
/// [package]
/// name = "nanobot"
/// version = "0.1.0"
/// "#;
///
/// let s3 = r#"
/// [package]
/// name = "nanobot"
/// version = "0.1.0"
/// edition = "2021"
/// "#;
///
/// let v1 = s1.parse::<Value>().unwrap();
/// let v2 = s2.parse::<Value>().unwrap();
/// let expected = s3.parse::<Value>().unwrap();
///
/// let merged = merge(v1,v2);
///
/// assert_eq!(expected, merged);
/// ```
fn merge(v1: &Value, v2: &Value) -> Value {
    match v1 {
        Value::Table(x) => match v2 {
            Value::Table(y) => {
                let mut merge_table = Map::new();
                for (k, v) in x {
                    if y.contains_key(k) {
                        let yv = y.get(k).unwrap();
                        let m = merge(v, yv);
                        merge_table.insert(k.clone(), m);
                    } else {
                        merge_table.insert(k.clone(), v.clone());
                    }
                }
                for (k, v) in y {
                    if !merge_table.contains_key(k) {
                        merge_table.insert(k.clone(), v.clone());
                    }
                }
                Value::Table(merge_table)
            }
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::Array(x) => match v2 {
            Value::Array(y) => {
                let mut merged = [&x[..], &y[..]].concat();
                merged.dedup();
                Value::Array(merged)
            }
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::String(_x) => match v2 {
            Value::String(y) => Value::String(y.clone()),
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::Integer(_x) => match v2 {
            Value::Integer(y) => Value::Integer(y.clone()),
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::Float(_x) => match v2 {
            Value::Float(y) => Value::Float(y.clone()),
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::Boolean(_x) => match v2 {
            Value::Boolean(y) => Value::Boolean(y.clone()),
            _ => panic!("Cannot merge inconsistent types."),
        },
        Value::Datetime(_x) => match v2 {
            Value::Datetime(y) => Value::Datetime(y.clone()),
            _ => panic!("Cannot merge inconsistent types."),
        },
    }
}

fn config(file_path: &str) -> Result<String, String> {
    let default_config = fs::read_to_string("src/resources/default_config.toml")
        .expect("Should have been able to read the file");

    let input_config =
        fs::read_to_string(file_path).expect("Should have been able to read the file");

    let input_value = input_config.parse::<Value>().unwrap();
    let default_value = default_config.parse::<Value>().unwrap();

    let value_table = input_value.as_table().unwrap();
    let default_table = default_value.as_table().unwrap();

    let mut merge_table = Map::new();
    merge_table.clone_from(&value_table);

    for (k, v) in default_table.iter() {
        if !value_table.contains_key(k) {
            merge_table.insert(k.clone(), v.clone());
        } else {
            let v2 = value_table.get(k).unwrap();
            let merged = merge(v, v2);
            merge_table.insert(k.clone(), merged);
        }
    }

    let merge_value = Value::Table(merge_table);
    let toml = toml::to_string(&merge_value).unwrap();

    Ok(toml)
}

#[async_std::main]
async fn main() {
    let matches = command!() // requires `cargo` feature
        .propagate_version(true)
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(
            Command::new("init").about("Initialises things").arg(
                arg!(
                    -d --database <FILE> "Specifies a custom database name"
                )
                .required(false)
                .value_parser(value_parser!(String)),
            ),
        )
        .subcommand(Command::new("config").about("Configures things"))
        .get_matches();

    let exit_result = match matches.subcommand() {
        Some(("init", sub_matches)) => match sub_matches.get_one::<String>("database") {
            Some(x) => init(x).await,
            _ => init(".nanobot.db").await,
        },
        Some(("config", _sub_matches)) => config("nanobot.toml"), 
        _ => unreachable!("Exhausted list of subcommands and subcommand_required prevents `None`"),
    };

    //print exit message
    match exit_result {
        Err(x) => {
            println!("{}", x);
            std::process::exit(1)
        }

        Ok(x) => println!("{}", x),
    }
}
